<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AddRemoveItems" xml:space="preserve">
    <value>Add/Remove Items</value>
  </data>
  <data name="Cancel" xml:space="preserve">
    <value>Cancel</value>
  </data>
  <data name="DataBinding" xml:space="preserve">
    <value>Data Binding</value>
  </data>
  <data name="EnterIndexValue" xml:space="preserve">
    <value>Enter the index at which to insert the new item.  Valid values are 0-{0}.</value>
  </data>
  <data name="Error" xml:space="preserve">
    <value>Error</value>
  </data>
  <data name="FileIO" xml:space="preserve">
    <value>File IO</value>
  </data>
  <data name="FileWrittenSuccessfully" xml:space="preserve">
    <value>File Written Successfully</value>
  </data>
  <data name="IndexOutOfRange" xml:space="preserve">
    <value>Index value is out of range.</value>
  </data>
  <data name="InvalidIndexValue" xml:space="preserve">
    <value>Index value is invalid.</value>
  </data>
  <data name="IOWriteError" xml:space="preserve">
    <value>IO Write Error</value>
  </data>
  <data name="Item" xml:space="preserve">
    <value>Item</value>
  </data>
  <data name="ListBoxAddRemoveSampleDescription" xml:space="preserve">
    <value>This sample demonstrates dynamic insertion and removal of items from the ListBox control.  Use the buttons in the menu to manipulate the list.</value>
  </data>
  <data name="OK" xml:space="preserve">
    <value>OK</value>
  </data>
  <data name="ReadWrite" xml:space="preserve">
    <value>Read/Write</value>
  </data>
  <data name="ReadWriteSampleDescription" xml:space="preserve">
    <value>This sample demonstrates writing to and reading from a file on the hard disk.  Type some text below and press the Write button in the menu to write it to a file.  This file will persist for as long as the application is installed.  Press the Read button in the menu to read the text that was last saved to the file and have it inserted below.</value>
  </data>
  <data name="SystemsAndSensors" xml:space="preserve">
    <value>Systems and Sensors</value>
  </data>
  <data name="TableOfContentsGreeting" xml:space="preserve">
    <value>This application demonstrates various features of the Prism framework.  All code written for the application is free to use, copy, etc.</value>
  </data>
  <data name="TableOfContentsInstructions" xml:space="preserve">
    <value>Select an option below to begin.</value>
  </data>
  <data name="TableOfContentsTitle" xml:space="preserve">
    <value>Table of Contents</value>
  </data>
  <data name="UIControls" xml:space="preserve">
    <value>UI Controls</value>
  </data>
  <data name="UnknownCategoryError" xml:space="preserve">
    <value>The specified category could not be found.  Please go back and select a different one.</value>
  </data>
  <data name="MultiBinding" xml:space="preserve">
    <value>MultiBinding</value>
  </data>
  <data name="SingleBinding" xml:space="preserve">
    <value>Single Binding</value>
  </data>
  <data name="Blue" xml:space="preserve">
    <value>Blue:</value>
  </data>
  <data name="Green" xml:space="preserve">
    <value>Green:</value>
  </data>
  <data name="Mode" xml:space="preserve">
    <value>Mode: {0}</value>
  </data>
  <data name="MultiBindingSampleDescription" xml:space="preserve">
    <value>This sample demonstrates a data binding with a target property bound to multiple source properties.  Each one of the sliders here determine one of the color components for the UI element below.  Every time one of the slider values is changed, the color is changed to match the values of all sliders.  Additionally, this sample also demonstrates how individual bindings that make up a MultiBinding can define their own behavioral characteristics, in this case having a different mode for the label text that shows the color value.  While the sliders all go from source (the sliders) to target (the color display), the label, which is also part of the binding to the color display, goes from target (the color display) to source (the label).  This allows the label to read the color value of the display element and show the text value of that color.</value>
  </data>
  <data name="Red" xml:space="preserve">
    <value>Red:</value>
  </data>
  <data name="RGB" xml:space="preserve">
    <value>R: {0}, G: {1}, B: {2}</value>
  </data>
  <data name="SingleBindingSampleDescription" xml:space="preserve">
    <value>This sample demonstrates a simple data binding between two objects.  As the text of one TextBox changes, the text of the other TextBox will change to match it.  You can change the direction of the binding by pressing the button below.</value>
  </data>
  <data name="SourceObject" xml:space="preserve">
    <value>Source Object:</value>
  </data>
  <data name="TargetObject" xml:space="preserve">
    <value>Target Object:</value>
  </data>
  <data name="RootViews" xml:space="preserve">
    <value>Root Views</value>
  </data>
  <data name="RootViewSampleDescription" xml:space="preserve">
    <value>This sample demonstrates different kinds of root views for the application window.  When you select one of the options below, the content of the application window will be set to the selected option and you will be brought back to the Table of Contents.</value>
  </data>
  <data name="SingleView" xml:space="preserve">
    <value>Single View</value>
  </data>
  <data name="SplitView" xml:space="preserve">
    <value>SplitView</value>
  </data>
  <data name="Tab" xml:space="preserve">
    <value>Tab {0}</value>
  </data>
  <data name="TabbedSplitView" xml:space="preserve">
    <value>TabbedSplitView</value>
  </data>
  <data name="TabView" xml:space="preserve">
    <value>TabView</value>
  </data>
  <data name="Normal" xml:space="preserve">
    <value>Normal</value>
  </data>
  <data name="Rotation" xml:space="preserve">
    <value>Rotation</value>
  </data>
  <data name="Scale" xml:space="preserve">
    <value>Scale</value>
  </data>
  <data name="Skew" xml:space="preserve">
    <value>Skew</value>
  </data>
  <data name="Transform" xml:space="preserve">
    <value>Transform</value>
  </data>
  <data name="TransformSampleDescription" xml:space="preserve">
    <value>This sample demonstrates the use of different transforming options to modify the way that an element is rendered.  The 'Normal' example shows what the element looks like without any transformation applied to it.  The other examples show the use of TranslateTransform, RotateTransform, ScaleTransform, and SkewTransform.</value>
  </data>
  <data name="Translation" xml:space="preserve">
    <value>Translation</value>
  </data>
  <data name="ListBoxSectioningSampleDescription" xml:space="preserve">
    <value>This sample demonstrates the ListBox's ability to divide its content into separate sections.  Each section comes with its own customizable header that serves as a separator between itself and the previous section.  Typically, this header will "float" on top of the section's content, staying in view until the rest of the section is scrolled out of sight.</value>
  </data>
  <data name="Section" xml:space="preserve">
    <value>Section</value>
  </data>
  <data name="Sectioning" xml:space="preserve">
    <value>Sectioning</value>
  </data>
</root>