<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AddRemoveItems" xml:space="preserve">
    <value>Add/Remove Items</value>
  </data>
  <data name="Cancel" xml:space="preserve">
    <value>Cancel</value>
  </data>
  <data name="DataBinding" xml:space="preserve">
    <value>Data Binding</value>
  </data>
  <data name="EnterIndexValue" xml:space="preserve">
    <value>Enter the index at which to insert the new item.  Valid values are 0-{0}.</value>
  </data>
  <data name="Error" xml:space="preserve">
    <value>Error</value>
  </data>
  <data name="FileIO" xml:space="preserve">
    <value>File IO</value>
  </data>
  <data name="FileWrittenSuccessfully" xml:space="preserve">
    <value>File Written Successfully</value>
  </data>
  <data name="IndexOutOfRange" xml:space="preserve">
    <value>Index value is out of range.</value>
  </data>
  <data name="InvalidIndexValue" xml:space="preserve">
    <value>Index value is invalid.</value>
  </data>
  <data name="IOWriteError" xml:space="preserve">
    <value>IO Write Error</value>
  </data>
  <data name="Item" xml:space="preserve">
    <value>Item</value>
  </data>
  <data name="ListBoxAddRemoveSampleDescription" xml:space="preserve">
    <value>This sample demonstrates dynamic insertion and removal of items from the ListBox control.  Use the buttons in the menu to manipulate the list.</value>
  </data>
  <data name="OK" xml:space="preserve">
    <value>OK</value>
  </data>
  <data name="ReadWrite" xml:space="preserve">
    <value>Read/Write</value>
  </data>
  <data name="ReadWriteSampleDescription" xml:space="preserve">
    <value>This sample demonstrates writing to and reading from a file on the hard disk.  Type some text below and press the Write button in the menu to write it to a file.  This file will persist for as long as the application is installed.  Press the Read button in the menu to read the text that was last saved to the file and have it inserted below.</value>
  </data>
  <data name="SystemsAndSensors" xml:space="preserve">
    <value>Systems and Sensors</value>
  </data>
  <data name="TableOfContentsGreeting" xml:space="preserve">
    <value>This application demonstrates various features of the Prism framework.  All code written for the application is free to use, copy, etc.</value>
  </data>
  <data name="TableOfContentsInstructions" xml:space="preserve">
    <value>Select an option below to begin.</value>
  </data>
  <data name="TableOfContentsTitle" xml:space="preserve">
    <value>Table of Contents</value>
  </data>
  <data name="UIControls" xml:space="preserve">
    <value>UI Controls</value>
  </data>
  <data name="UnknownCategoryError" xml:space="preserve">
    <value>The specified category could not be found.  Please go back and select a different one.</value>
  </data>
  <data name="MultiBinding" xml:space="preserve">
    <value>MultiBinding</value>
  </data>
  <data name="SingleBinding" xml:space="preserve">
    <value>Single Binding</value>
  </data>
  <data name="Blue" xml:space="preserve">
    <value>Blue:</value>
  </data>
  <data name="Green" xml:space="preserve">
    <value>Green:</value>
  </data>
  <data name="Mode" xml:space="preserve">
    <value>Mode: {0}</value>
  </data>
  <data name="MultiBindingSampleDescription" xml:space="preserve">
    <value>This sample demonstrates a data binding with a target property bound to multiple source properties.  Each one of the sliders here determine one of the color components for the UI element below.  Every time one of the slider values is changed, the color is changed to match the values of all sliders.  Additionally, this sample also demonstrates how individual bindings that make up a MultiBinding can define their own behavioral characteristics, in this case having a different mode for the label text that shows the color value.  While the sliders all go from source (the sliders) to target (the color display), the label, which is also part of the binding to the color display, goes from target (the color display) to source (the label).  This allows the label to read the color value of the display element and show the text value of that color.</value>
  </data>
  <data name="Red" xml:space="preserve">
    <value>Red:</value>
  </data>
  <data name="RGB" xml:space="preserve">
    <value>R: {0}, G: {1}, B: {2}</value>
  </data>
  <data name="SingleBindingSampleDescription" xml:space="preserve">
    <value>This sample demonstrates a simple data binding between two objects.  As the text of one TextBox changes, the text of the other TextBox will change to match it.  You can change the direction of the binding by pressing the button below.</value>
  </data>
  <data name="SourceObject" xml:space="preserve">
    <value>Source Object:</value>
  </data>
  <data name="TargetObject" xml:space="preserve">
    <value>Target Object:</value>
  </data>
  <data name="RootViews" xml:space="preserve">
    <value>Root Views</value>
  </data>
  <data name="RootViewSampleDescription" xml:space="preserve">
    <value>This sample demonstrates different kinds of root views for the application window.  The SplitView with TabView combination places SplitViews inside of the tabs of a TabView.  For an alternative effect, you could try placing a TabView inside of a SplitView.  When you select one of the options below, the content of the application window will be set to the selected option and you will be brought back to the Table of Contents.</value>
  </data>
  <data name="SingleView" xml:space="preserve">
    <value>Single View</value>
  </data>
  <data name="SplitView" xml:space="preserve">
    <value>SplitView</value>
  </data>
  <data name="Tab" xml:space="preserve">
    <value>Tab {0}</value>
  </data>
  <data name="SplitViewWithTabs" xml:space="preserve">
    <value>SplitView + Tabs</value>
  </data>
  <data name="TabView" xml:space="preserve">
    <value>TabView</value>
  </data>
  <data name="Normal" xml:space="preserve">
    <value>Normal</value>
  </data>
  <data name="Rotation" xml:space="preserve">
    <value>Rotation</value>
  </data>
  <data name="Scale" xml:space="preserve">
    <value>Scale</value>
  </data>
  <data name="Skew" xml:space="preserve">
    <value>Skew</value>
  </data>
  <data name="Transform" xml:space="preserve">
    <value>Transform</value>
  </data>
  <data name="TransformSampleDescription" xml:space="preserve">
    <value>This sample demonstrates the use of different transforming options to modify the way that an element is rendered.  The 'Normal' example shows what the element looks like without any transformation applied to it.  The other examples show the use of TranslateTransform, RotateTransform, ScaleTransform, and SkewTransform.</value>
  </data>
  <data name="Translation" xml:space="preserve">
    <value>Translation</value>
  </data>
  <data name="ListBoxSectioningSampleDescription" xml:space="preserve">
    <value>This sample demonstrates the ListBox's ability to divide its content into separate sections.  Each section comes with its own customizable header that serves as a separator between itself and the previous section.  Typically, this header will "float" on top of the section's content, staying in view until the rest of the section is scrolled out of sight.</value>
  </data>
  <data name="Section" xml:space="preserve">
    <value>Section</value>
  </data>
  <data name="Sectioning" xml:space="preserve">
    <value>Sectioning</value>
  </data>
  <data name="Brushes" xml:space="preserve">
    <value>Brushes</value>
  </data>
  <data name="BrushesSampleDescription" xml:space="preserve">
    <value>This sample demonstrates the different brushes that can be used to style UI elements.  Some objects are limited in the type of brush that they can use.  This limitation is determined by the object's native implementation that is provided by each platform, which means that different results could be seen depending on the platform being run.  If a brush cannot be used, a default value provided by the system will be used in its place.</value>
  </data>
  <data name="Shapes" xml:space="preserve">
    <value>Shapes</value>
  </data>
  <data name="ShapesSampleDescription" xml:space="preserve">
    <value>This sample demonstrates the various shape elements that can be used to programmatically draw graphics in an application.  Shapes can be stroked, filled, and dashed.  Path shapes in particular allow for multiple complex figures within a single element by defining groups of lines, arcs, and curves.</value>
  </data>
  <data name="ToggleDash" xml:space="preserve">
    <value>Toggle Dash</value>
  </data>
  <data name="Clear" xml:space="preserve">
    <value>Clear</value>
  </data>
  <data name="InkCanvasSampleDescription" xml:space="preserve">
    <value>This sample demonstrates the InkCanvas control, which allows users to draw ink strokes with an input device such as a mouse or a stylus.</value>
  </data>
  <data name="PenSizeAndShape" xml:space="preserve">
    <value>Pen Size and Shape</value>
  </data>
  <data name="Back" xml:space="preserve">
    <value>Back</value>
  </data>
  <data name="Forward" xml:space="preserve">
    <value>Forward</value>
  </data>
  <data name="Go" xml:space="preserve">
    <value>Go</value>
  </data>
  <data name="Refresh" xml:space="preserve">
    <value>Refresh</value>
  </data>
  <data name="WebBrowserSampleDescription" xml:space="preserve">
    <value>This sample demonstrates the WebBrowser control, which is able to navigate to web addresses and render HTML content within the application.  The URI must be exact, and it must include the protocol (http, https, ftp, etc.).</value>
  </data>
  <data name="Action" xml:space="preserve">
    <value>Action</value>
  </data>
  <data name="InputType" xml:space="preserve">
    <value>Input Type</value>
  </data>
  <data name="PointerEvents" xml:space="preserve">
    <value>Pointer Events</value>
  </data>
  <data name="PointerEventsSampleDescription" xml:space="preserve">
    <value>This sample demonstrates the ability to capture events from pointer devices such as a mouse, a stylus, or a finger on a touch screen.  When a UI element detects an event from one of these devices, it sends information about the event to the application.  This information includes the type of the pointer device, the location of the pointer relative to the element, the pressure being applied by the pointer, and a time stamp provided by the system.</value>
  </data>
  <data name="Position" xml:space="preserve">
    <value>Position</value>
  </data>
  <data name="Pressure" xml:space="preserve">
    <value>Pressure</value>
  </data>
  <data name="Timestamp" xml:space="preserve">
    <value>Timestamp</value>
  </data>
  <data name="Flyout" xml:space="preserve">
    <value>Flyout</value>
  </data>
  <data name="FlyoutContent" xml:space="preserve">
    <value>This is a content flyout.  It renders UI elements and is dismissed when the user taps outside of its bounds.</value>
  </data>
  <data name="FlyoutSampleDescription" xml:space="preserve">
    <value>This sample demonstrates the Flyout object.  Flyouts appear over regular application content much like a Popup.  Unlike a Popup, however, Flyouts are anchored to other UI elements and will always be dismissed when the user taps outside of their bounds.  Flyouts come in two flavors: a content flyout and a menu flyout.  Content flyouts show a UI element in the same manner that a Popup does; menu flyouts present a list of selectable options and dismiss themselves when an option is chosen.</value>
  </data>
  <data name="MenuFlyout" xml:space="preserve">
    <value>Menu Flyout</value>
  </data>
  <data name="Option" xml:space="preserve">
    <value>Option</value>
  </data>
  <data name="Image" xml:space="preserve">
    <value>Image</value>
  </data>
  <data name="ImageSampleDescription" xml:space="preserve">
    <value>This sample demonstrates the Image element, which renders image data taken from a local or remote file.  Images have several stretching options that affect the way they fill their parent space.  These stretching options can be seen below.</value>
  </data>
</root>